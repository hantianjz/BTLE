#!/usr/bin/env bash
set -o nounset  # Fail on unset variable expansion.
set -o pipefail # Inherit pipe failures.

# Runs ./b any time a file is changed in the repository.
# Inspired by the google3 tool iblaze (go/iblaze).

SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
IB_LOCKFILE="$SCRIPT_DIR/.ib_lock"
BUILD_SCRIPT="$SCRIPT_DIR/b"
BUILD_STATE_FILE="/tmp/babycare_build_state"

# Values to write to BUILD_STATE_FILE.
BUILD_STATE_SUCCESS="0"
BUILD_STATE_FAILURE="1"
BUILD_STATE_IN_PROGRESS="2"
BUILD_STATE_ENDED="3"

function vce_cleanup() {
  [ -f "$IB_LOCKFILE" ] && rm "$IB_LOCKFILE"
  echo "${BUILD_STATE_ENDED}" > ${BUILD_STATE_FILE}
  exit 0
}

# Don't run multiple instances of ib or bad things will happen.
if [ -f "$IB_LOCKFILE" ]; then
  echo "Looks like ib is already running. If not, delete .ib_lock and rerun."
  exit 1
fi

touch "$IB_LOCKFILE"

# Always delete the lock file on exit.
trap vce_cleanup INT TERM

PLATFORM=$(uname)
EXCLUDE_REGEXES='--exclude .git --exclude out --exclude .duratool_history'

if [[ $PLATFORM == "Linux" ]]; then
  command -v inotifywait > /dev/null || { \
    echo >&2 "inotifywait not found. Install with: sudo apt-get install inotify-tools"; \
    exit 1; }
  MONITOR_COMMAND="inotifywait -qqr ${EXCLUDE_REGEXES} --event modify $SCRIPT_DIR/"
  SED_UNBUFFERED_FLAG="-u"
elif [[ $PLATFORM == "Darwin" ]]; then
  command -v fswatch > /dev/null || { \
    echo >&2 "fswatch not found. Install with: brew install fswatch"; \
    exit 1; }
  MONITOR_COMMAND="fswatch --one-event --recursive ${EXCLUDE_REGEXES} $SCRIPT_DIR/"
  SED_UNBUFFERED_FLAG="-l"
else
  echo "$0 only supports Linux and MacOS (your platform is ${PLATFORM})."
  exit 1
fi

# Terminal color codes.
RED='\033[0;31m'
GREEN='\033[0;32m'
NO_COLOR='\033[0m'

while true; do
  # If a git operation (e.g. git pull) is in progress then don't start a build.
  if [[ -f $SCRIPT_DIR/.git/index.lock ]]; then
    echo -e "${GREEN}*** Git operation in progress, not building yet.${NO_COLOR}\n";
  else
    SECONDS=0 # SECONDS is a bash variable that tracks time automatically
    echo -e "${GREEN}*** Starting a build...${NO_COLOR}\n";

    echo "${BUILD_STATE_IN_PROGRESS}" > ${BUILD_STATE_FILE}

    # Run the build script.
    "$BUILD_SCRIPT" "$@"

    SUCCESS=$?
    if [[ $SUCCESS == 0 ]]; then
      COLOR=${GREEN}; MSG="Succeeded"
      echo "${BUILD_STATE_SUCCESS}" > ${BUILD_STATE_FILE}
    else
      COLOR=${RED}; MSG="Failed"
      echo "${BUILD_STATE_FAILURE}" > ${BUILD_STATE_FILE}
    fi
    echo -e "\n${COLOR}*** Build ${MSG} after ${SECONDS} seconds!" \
            "Watching for new changes.${NO_COLOR}\n\n"
  fi

  # Command blocks until a file is changed.
  $MONITOR_COMMAND > /dev/null
done
